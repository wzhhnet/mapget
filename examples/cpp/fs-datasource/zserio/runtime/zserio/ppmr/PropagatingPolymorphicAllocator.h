#ifndef ZSERIO_PPMR_PROPAGATING_POLYMORPHIC_ALLOCATOR_H_INC
#define ZSERIO_PPMR_PROPAGATING_POLYMORPHIC_ALLOCATOR_H_INC

#include <cstddef>
#include <memory_resource>

namespace zserio
{
namespace ppmr
{

/**
 * Propagating version of the polymorphic allocator. This one is propagated on container copy and assignment.
 */
template <class T>
class PropagatingPolymorphicAllocator
{
public:
    using value_type = T;

    using propagate_on_container_copy_assignment = std::true_type;
    using propagate_on_container_move_assignment = std::true_type;
    using propagate_on_container_swap = std::true_type;

    /**
     * Constructor.
     *
     * Note that this is intentionally non-explicit to allow to pass MemoryResource wherever
     * the PropagatingPolymorphicAllocator is required.
     *
     * \param resource Memory resource. According to the C++ standard the resource may not be NULL. Since it
     *                 implies undefined behaviour, we define a non-standard extension here. When the resource
     *                 is NULL, std::pmr::get_default_resource() is used instead!
     */
    PropagatingPolymorphicAllocator(
            std::pmr::memory_resource* resource = std::pmr::get_default_resource()) noexcept :
            m_resource(
                    resource != nullptr ? resource : std::pmr::get_default_resource()) // non-standard extension
    {}

    /**
     * Method generated by default.
     * \{
     */
    ~PropagatingPolymorphicAllocator() = default;

    PropagatingPolymorphicAllocator(const PropagatingPolymorphicAllocator& other) noexcept = default;
    PropagatingPolymorphicAllocator& operator=(const PropagatingPolymorphicAllocator& other) noexcept = default;

    PropagatingPolymorphicAllocator(PropagatingPolymorphicAllocator&& other) noexcept = default;
    PropagatingPolymorphicAllocator& operator=(PropagatingPolymorphicAllocator&& other) noexcept = default;
    /**
     * \}
     */

    /**
     * Copy constructor from PropagatingPolymorphicAllocator with another value_type.
     *
     * \param other Other PropagatingPolymorphicAllocator.
     */
    template <class U>
    PropagatingPolymorphicAllocator(const PropagatingPolymorphicAllocator<U>& other) noexcept :
            m_resource(other.resource())
    {}

    /**
     * Assignment operator from PropagatingPolymorphicAllocator with another value_type.
     *
     * \param other Other PropagatingPolymorphicAllocator.
     */
    template <class U>
    PropagatingPolymorphicAllocator& operator=(const PropagatingPolymorphicAllocator<U>& other) noexcept
    {
        m_resource = other.resource();
        return *this;
    }
    /**
     * Allocates memory for n values.
     *
     * \param size Number of values to allocate memory for.
     */
    value_type* allocate(std::size_t size)
    {
        return static_cast<value_type*>(m_resource->allocate(size * sizeof(value_type), alignof(value_type)));
    }

    /**
     * Deallocates memory for n values.
     *
     * \param memory Pointer to the memory to deallocate.
     * \param size Number of values held by the memory pointed to by memory.
     *         Shall be the same size as was used for allocation of memory.
     */
    void deallocate(value_type* memory, std::size_t size) noexcept
    {
        m_resource->deallocate(memory, size * sizeof(value_type), alignof(value_type));
    }

    /**
     * Constructs an object in allocated memory.
     *
     * \param ptr Pointer to memory where the object will be constructed.
     * \param args Parameters to be forwarded to the object constructor.
     */
    template <typename U, typename... Args>
    void construct(U* ptr, Args&&... args)
    {
        using Self = decltype(*this);
        if constexpr (std::uses_allocator_v<std::remove_cv_t<U>, Self>)
        {
            if constexpr (std::is_constructible_v<U, std::allocator_arg_t, Self, Args...>)
            {
                new (static_cast<void*>(ptr)) U(std::allocator_arg, *this, std::forward<Args>(args)...);
            }
            else
            {
                new (static_cast<void*>(ptr)) U(std::forward<Args>(args)..., *this);
            }
        }
        else
        {
            new (static_cast<void*>(ptr)) U(std::forward<Args>(args)...);
        }
    }

    /**
     * Destroys an object
     *
     * \param ptr Pointer to the object to be destroyed.
     */
    template <typename U>
    void destroy(U* ptr) noexcept(noexcept(ptr->~U()))
    {
        ptr->~U();
    }

    /**
     * Returns instance of the allocator to be used when a container gets copied.
     */
    PropagatingPolymorphicAllocator select_on_container_copy_construction() const
    {
        return *this;
    }

    /**
     * Gets the underlying memory resource.
     */
    std::pmr::memory_resource* resource() const noexcept
    {
        return m_resource;
    }

private:
    std::pmr::memory_resource* m_resource;
};

template <class T, class U>
bool operator==(
        const PropagatingPolymorphicAllocator<T>& lhs, const PropagatingPolymorphicAllocator<U>& rhs) noexcept
{
    return *lhs.resource() == *rhs.resource();
}

template <class T, class U>
bool operator!=(
        const PropagatingPolymorphicAllocator<T>& lhs, const PropagatingPolymorphicAllocator<U>& rhs) noexcept
{
    return !(lhs == rhs);
}

} // namespace ppmr
} // namespace zserio

#endif // ZSERIO_PPMR_PROPAGATING_POLYMORPHIC_ALLOCATOR_H_INC
