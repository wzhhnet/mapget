#ifndef ZSERIO_ISERVICE_H_INC
#define ZSERIO_ISERVICE_H_INC

#include <string_view>

#include "zserio/IIntrospectableView.h"
#include "zserio/SerializeUtil.h"
#include "zserio/Span.h"
#include "zserio/Types.h"
#include "zserio/Vector.h"
#include "zserio/View.h"

namespace zserio
{

/**
 * Service data interface.
 *
 * When introspectable interface is available, holds the introspectable object, otherwise holds serialized data.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class IBasicServiceData
{
public:
    /** Destructor. */
    virtual ~IBasicServiceData() = default;

    /**
     * Gets introspectable representing the service data (if available).
     *
     * \return Introspectable or null when no introspectable is available.
     */
    virtual IBasicIntrospectableViewConstPtr<ALLOC> getIntrospectable() const = 0;

    /**
     * Gets service data as bytes.
     *
     * \return Service data.
     */
    virtual Span<const uint8_t> getData() const = 0;
};

/** Typedef to service data smart pointer needed for convenience in generated code. */
template <typename ALLOC = std::allocator<uint8_t>>
using IBasicServiceDataPtr = std::shared_ptr<IBasicServiceData<ALLOC>>;

/**
 * Service data implementation based on introspectable interface.
 *
 * Holds reference to the introspectable object and lazy-initialized serialized data in case that
 * getData() is used.
 */
template <typename ZSERIO_OBJECT, typename ALLOC = std::allocator<uint8_t>>
class BasicIntrospectableServiceData : public IBasicServiceData<ALLOC>
{
public:
    /**
     * Constructor from introspectable.
     *
     * \param introspectable Constant introspectable created from zserio request object.
     * \param allocator Allocator to use for data allocation.
     */
    explicit BasicIntrospectableServiceData(ZSERIO_OBJECT&& response, const ALLOC& allocator = ALLOC()) :
            m_response(std::move(response)),
            m_introspectable(introspectable(View(m_response), allocator)),
            m_data(allocator)
    {}

    IBasicIntrospectableViewConstPtr<ALLOC> getIntrospectable() const override
    {
        return m_introspectable;
    }

    /**
     * Lazy initialized data serialized using the introspectable object.
     *
     * \copydoc IBasicServiceData::getData()
     */
    Span<const uint8_t> getData() const override
    {
        if (m_introspectable && m_data.getBitSize() == 0)
        {
            // lazy initialization
            m_data = m_introspectable->serialize(m_data.get_allocator());
        }
        return m_data.getData();
    }

private:
    ZSERIO_OBJECT m_response;
    IBasicIntrospectableViewConstPtr<ALLOC> m_introspectable;
    mutable BasicBitBuffer<ALLOC> m_data;
};

/**
 * Service data implementation based on objects generated by Zserio.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class BasicObjectServiceData : public IBasicServiceData<ALLOC>
{
public:
    /**
     * Constructor from zserio-generated object.
     *
     * \param object Reference to zserio object.
     * \param allocator Allocator to use for data allocation
     */
    template <typename ZSERIO_OBJECT>
    explicit BasicObjectServiceData(const ZSERIO_OBJECT& object, const ALLOC& allocator = ALLOC()) :
            m_data(zserio::serialize(object, allocator))
    {}

    IBasicIntrospectableViewConstPtr<ALLOC> getIntrospectable() const override
    {
        return nullptr;
    }

    Span<const uint8_t> getData() const override
    {
        return m_data.getData();
    }

private:
    BasicBitBuffer<ALLOC> m_data;
};

/**
 * Service data implementation which owns the data.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class BasicRawServiceDataHolder : public IBasicServiceData<ALLOC>
{
public:
    /**
     * Constructor from vector const l-value reference.
     *
     * \param rawData Raw data to be copied inside the service data.
     */
    explicit BasicRawServiceDataHolder(const Vector<uint8_t, ALLOC>& rawData) :
            m_data(rawData)
    {}

    /**
     * Constructor from vector r-value reference.
     *
     * \param rawData Raw data to be moved inside the service data.
     */
    explicit BasicRawServiceDataHolder(Vector<uint8_t, ALLOC>&& rawData) :
            m_data(std::move(rawData))
    {}

    IBasicIntrospectableViewConstPtr<ALLOC> getIntrospectable() const override
    {
        return nullptr;
    }

    Span<const uint8_t> getData() const override
    {
        return m_data;
    }

private:
    Vector<uint8_t, ALLOC> m_data;
};

/**
 * Service data implementation which only keeps pointer to the raw data buffer.
 *
 * Must be used with caution only when the proper life-time of the data is ensured.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class BasicRawServiceDataView : public IBasicServiceData<ALLOC>
{
public:
    /**
     * Constructor from span.
     *
     * \param rawData Span as a pointer to the raw data buffer.
     */
    explicit BasicRawServiceDataView(zserio::Span<const uint8_t> rawData) :
            m_data(rawData)
    {}

    IBasicIntrospectableViewConstPtr<ALLOC> getIntrospectable() const override
    {
        return nullptr;
    }

    Span<const uint8_t> getData() const override
    {
        return m_data;
    }

private:
    Span<const uint8_t> m_data;
};

/**
 * Generic interface for all Zserio services to be used on the server side.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class IBasicService
{
public:
    virtual ~IBasicService() = default;

    /**
     * Calls method with the given name synchronously.
     *
     * \param methodName Name of the service method to call.
     * \param requestData Request data to be passed to the method.
     * \param context Context specific for particular service or nullptr in case of no context.
     *
     * \return Created response data.
     *
     * \throw ServiceException if the call fails.
     */
    virtual IBasicServiceDataPtr<ALLOC> callMethod(
            std::string_view methodName, Span<const uint8_t> requestData, void* context) = 0;
};

/**
 * Generic interface for all Zserio services to be used on the client side.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class IBasicServiceClient
{
public:
    virtual ~IBasicServiceClient() = default;

    /**
     * Calls method with the given name synchronously.
     *
     * \param methodName Name of the service method to call.
     * \param requestData Request data to be passed to the method.
     * \param context Context specific for particular service or nullptr in case of no context.
     *
     * \return Created response data as bytes.
     *
     * \throw ServiceException if the call fails.
     */
    virtual Vector<uint8_t, ALLOC> callMethod(
            std::string_view methodName, const IBasicServiceData<ALLOC>& requestData, void* context) = 0;
};

/** Typedef to service interface provided for convenience - using default std::allocator<uint8_t>. */
/** \{ */
using IServiceData = IBasicServiceData<>;
using IServiceDataPtr = IBasicServiceDataPtr<>;
using IService = IBasicService<>;
using IServiceClient = IBasicServiceClient<>;
/** \} */

/** Typedef to service data implementation provided for convenience - using default std::allocator<uint8_t>. */
/** \{ */
template <typename ZSERIO_OBJECT>
using IntrospectableServiceData = BasicIntrospectableServiceData<ZSERIO_OBJECT>;
using ObjectServiceData = BasicObjectServiceData<>;
using RawServiceDataHolder = BasicRawServiceDataHolder<>;
using RawServiceDataView = BasicRawServiceDataView<>;
/** \} */

} // namespace zserio

#endif // ifndef ZSERIO_ISERVICE_H_INC
