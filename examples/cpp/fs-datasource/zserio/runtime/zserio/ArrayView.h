#ifndef ZSERIO_ARRAY_H_INC
#define ZSERIO_ARRAY_H_INC

#include <string_view>
#include <type_traits>

#include "zserio/ArrayLengthException.h"
#include "zserio/ArrayTraits.h"
#include "zserio/BitPositionUtil.h"
#include "zserio/BitStreamReader.h"
#include "zserio/BitStreamWriter.h"

namespace zserio
{

namespace detail
{

/**
 * ArrayView type enum which defined type of the underlying array.
 */
enum ArrayType
{
    NORMAL, /**< Normal zserio array which has size defined by the Zserio schema. */
    IMPLICIT, /**< Implicit zserio array which size is defined by number of remaining bits in the bit stream. */
    ALIGNED, /**< Aligned zserio array which is normal zserio array with indexed offsets. */
    AUTO, /**< Auto zserio array which has size stored in a hidden field before the array. */
    ALIGNED_AUTO /**< Aligned auto zserio array which is auto zserio array with indexed offsets. */
};

} // namespace detail

template <typename T, typename ARRAY_TRAITS = ArrayTraits<std::remove_cv_t<T>>>
class ArrayView
{
public:
    /** Typedef for the value type. */
    using ValueType = std::remove_cv_t<T>;

    /** Typedef for the array traits. */
    using Traits = ARRAY_TRAITS;

    /** Forward declaration of the ArrayView const iterator. */
    class ConstIterator;

    using ConstReverseIterator = std::reverse_iterator<ConstIterator>;

    /**
     * Typedef for the array's owner type.
     *
     * Owner type is needed for proper expressions evaluation. If no owner is needed for expressions evaluation,
     * detail::DummyArrayOwner is used.
     */
    using OwnerType = detail::array_owner_type_t<Traits>;

    /**
     * Constructor from l-value raw array.
     *
     * \param rawArray Raw array.
     */
    template <typename OWNER_TYPE_ = OwnerType,
            std::enable_if_t<detail::is_dummy_array_owner_v<OWNER_TYPE_>, int> = 0>
    explicit ArrayView(Span<T> data) :
            m_data(data)
    {}

    /**
     * Constructor from l-value raw array.
     *
     * \param rawArray Raw array.
     * \param owner View to the array's owner.
     */
    template <typename OWNER_TYPE_ = OwnerType,
            std::enable_if_t<!detail::is_dummy_array_owner_v<OWNER_TYPE_>, int> = 0>
    explicit ArrayView(Span<T> data, const OwnerType& owner) :
            m_data(data),
            m_owner(owner)
    {}

    /**
     * Method generated by default.
     *
     * \{
     */
    ~ArrayView() = default;
    ArrayView(const ArrayView& other) = default;
    ArrayView& operator=(const ArrayView& other) = default;
    ArrayView(ArrayView&& other) = default;
    ArrayView& operator=(ArrayView&& other) = default;
    /**
     * \}
     */

    /**
     * Gets underlying raw data array.
     *
     * \return Reference to underlying data array.
     */
    /** \{ */
    Span<T> zserioData() const
    {
        return m_data;
    }
    /** \} */

    /**
     * Operator equality.
     *
     * \param other ArrayView to compare.
     *
     * \return True when the underlying raw arrays have same contents, false otherwise.
     */
    bool operator==(const ArrayView& other) const
    {
        const size_t thisSize = size();
        const size_t otherSize = other.size();
        if (thisSize != otherSize)
        {
            return false;
        }

        for (size_t i = 0; i < thisSize; ++i)
        {
            if ((*this)[i] != other[i])
            {
                return false;
            }
        }

        return true;
    }

    /**
     * Operator less than.
     *
     * \param other ArrayView to compare.
     *
     * \return True when this array is less than the other array, false otherwise.
     */
    bool operator<(const ArrayView& other) const
    {
        const size_t thisSize = size();
        const size_t otherSize = other.size();
        const size_t minSize = std::min(thisSize, otherSize);

        for (size_t i = 0; i < minSize; ++i)
        {
            if ((*this)[i] < other[i])
            {
                return true;
            }
            if (other[i] < (*this)[i])
            {
                return false;
            }
        }

        return thisSize < otherSize;
    }

    /**
     * Operator inequality.
     *
     * \param other ArrayView to compare.
     *
     * \return True when the arrays have different contents, false otherwise.
     */
    bool operator!=(const ArrayView& other) const
    {
        return !operator==(other);
    }

    /**
     * Operator greater than.
     *
     * \param other ArrayView to compare.
     *
     * \return True when this arrays is greater than the other array, false otherwise.
     */
    bool operator>(const ArrayView& other) const
    {
        return other.operator<(*this);
    }

    /**
     * Operator less than or equal.
     *
     * \param other ArrayView to compare.
     *
     * \return True when this arrays is less than or equal to the other array, false otherwise.
     */
    bool operator<=(const ArrayView& other) const
    {
        return !other.operator<(*this);
    }

    /**
     * Operator greater than or equal.
     *
     * \param other ArrayView to compare.
     *
     * \return True when this arrays is greater than or equal to the other array, false otherwise.
     */
    bool operator>=(const ArrayView& other) const
    {
        return !operator<(other);
    }

    /**
     * Gets length of the array.
     *
     * \return Length of the array.
     */
    size_t size() const
    {
        return m_data.size();
    }

    /**
     * Gets whether the array is empty.
     *
     * \return True when the array is empty, false otherwise.
     */
    bool empty() const
    {
        return m_data.empty();
    }

    /**
     * Returns element view at the given index.
     *
     * \param index Element index.
     * \return View to the specified element.
     */
    decltype(auto) at(size_t index) const
    {
        if (index >= m_data.size())
        {
            throw CppRuntimeException("ArrayView: Index ")
                    << index << " is out of bounds (" << m_data.size() << ")!";
        }

        return Traits::at(m_owner, m_data[index], index);
    }

    /**
     * Returns element view at the given index.
     * Like STL vector's operator[] this is does not check the array size.
     *
     * \param index Element index.
     * \return View to the specified element.
     */
    decltype(auto) operator[](size_t index) const
    {
        return Traits::at(m_owner, m_data[index], index);
    }

    /**
     * Returns element view for the first element in container.
     *
     * \return View to the first element.
     */
    decltype(auto) front() const
    {
        return at(0);
    }

    /**
     * Returns element view for the last element in container.
     *
     * \return View to the last element.
     */
    decltype(auto) back() const
    {
        return at(size() - 1);
    }

    /**
     * Returns an constant iterator to the beginning.
     *
     * \return Constant iterator to the beginning.
     */
    /** \{ */
    ConstIterator cbegin() const noexcept
    {
        return ConstIterator(this, 0);
    }

    ConstIterator begin() const noexcept
    {
        return cbegin();
    }
    /** \} */

    /**
     * Returns and constant iterator to the end.
     *
     * \return Constant iterator to the end.
     */
    /** \{ */
    ConstIterator cend() const noexcept
    {
        return ConstIterator(this, size());
    }

    ConstIterator end() const noexcept
    {
        return cend();
    }
    /** \} */

    /**
     * Returns an constant reverse iterator to the beginning of the reversed array.
     *
     * \return Constant reverse iterator to the beginning of the reversed array.
     */
    /** \{ */
    ConstReverseIterator crbegin() const noexcept
    {
        return ConstReverseIterator(end());
    }

    ConstReverseIterator rbegin() const noexcept
    {
        return crbegin();
    }
    /** \} */

    /**
     * Returns an constant reverse iterator to the end of the reversed array.
     *
     * \return Constant reverse iterator to the end of the reversed array.
     */
    /** \{ */
    ConstReverseIterator crend() const noexcept
    {
        return ConstReverseIterator(begin());
    }

    ConstReverseIterator rend() const noexcept
    {
        return crend();
    }
    /** \} */

    /**
     * Implementation of ArrayView constant iterator.
     */
    class ConstIterator
    {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = decltype(std::declval<ArrayView>().at(std::declval<size_t>()));
        using difference_type = std::ptrdiff_t;
        using pointer = void;
        using reference = value_type; // we always return by value!

        /** Helper needed to implement operator-> on the ConstIterator. */
        struct ArrowHelper
        {
            value_type* operator->()
            {
                return std::addressof(value);
            }

            value_type value;
        };

        ConstIterator(const ArrayView* array, size_t index) :
                m_array(array),
                m_index(index)
        {}

        value_type operator*() const
        {
            return m_array->at(m_index);
        }

        ArrowHelper operator->() const
        {
            return ArrowHelper{m_array->at(m_index)};
        }

        value_type operator[](difference_type offset) const
        {
            return m_array->at(m_index + static_cast<size_t>(offset));
        }

        ConstIterator& operator++()
        {
            ++m_index;
            return *this;
        }

        ConstIterator operator++(int)
        {
            ConstIterator tmp = *this;
            m_index++;
            return tmp;
        }

        ConstIterator& operator--()
        {
            --m_index;
            return *this;
        }

        ConstIterator operator--(int)
        {
            ConstIterator tmp = *this;
            m_index--;
            return tmp;
        }

        ConstIterator& operator+=(difference_type offset)
        {
            m_index += static_cast<size_t>(offset);
            return *this;
        }

        ConstIterator operator+(difference_type offset) const
        {
            return ConstIterator(m_array, m_index + static_cast<size_t>(offset));
        }

        friend ConstIterator operator+(difference_type offset, const ConstIterator& other)
        {
            return ConstIterator(other.m_array, other.m_index + static_cast<size_t>(offset));
        }

        ConstIterator& operator-=(difference_type offset)
        {
            m_index -= static_cast<size_t>(offset);
            return *this;
        }

        ConstIterator operator-(difference_type offset) const
        {
            return ConstIterator(m_array, m_index - static_cast<size_t>(offset));
        }

        difference_type operator-(const ConstIterator& other) const
        {
            return static_cast<difference_type>(m_index - other.m_index);
        }

        bool operator==(const ConstIterator& other) const
        {
            return m_index == other.m_index;
        }

        bool operator!=(const ConstIterator& other) const
        {
            return !(*this == other);
        }

        bool operator<(const ConstIterator& other) const
        {
            if (m_index != other.m_index)
            {
                return m_index < other.m_index;
            }

            return false;
        }

        bool operator>(const ConstIterator& other) const
        {
            return other < *this;
        }

        bool operator<=(const ConstIterator& other) const
        {
            return !(other < *this);
        }

        bool operator>=(const ConstIterator& other) const
        {
            return !(*this < other);
        }

    private:
        const ArrayView* m_array;
        size_t m_index;
    };

private:
    Span<T> m_data;
    OwnerType m_owner; // view to owner type, parameters are copied by value and that is ok
};

namespace detail
{

template <ArrayType ARRAY_TYPE, typename T, typename ARRAY_TRAITS>
void validate(const ArrayView<T, ARRAY_TRAITS>& array, std::string_view fieldName, size_t schemaSize = 0)
{
    if constexpr (ARRAY_TYPE == ArrayType::NORMAL || ARRAY_TYPE == ArrayType::ALIGNED)
    {
        if (array.size() != schemaSize)
        {
            throw ArrayLengthException("Wrong array length for field '")
                    << fieldName << "' (" << array.size() << " != " << schemaSize << ")!";
        }
    }

    validate(VarSize{convertSizeToUInt32(array.size())}, fieldName);

    for (size_t i = 0; i < array.size(); ++i)
    {
        validate(array[i], fieldName);
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ARRAY_TRAITS>
BitSize bitSizeOf(const ArrayView<T, ARRAY_TRAITS>& array, BitSize bitPosition = 0)
{
    BitSize endBitPosition = bitPosition;

    if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
    {
        endBitPosition += bitSizeOf(fromCheckedValue<VarSize>(convertSizeToUInt32(array.size())));
    }

    for (size_t i = 0; i < array.size(); ++i)
    {
        if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            endBitPosition = alignTo(8, endBitPosition);
        }

        endBitPosition += bitSizeOf(array[i], endBitPosition);
    }

    return endBitPosition - bitPosition;
}

struct DummyOffsetSetter
{
    static void setOffset(size_t /*index*/, BitSize /*byteOffset*/)
    {}
};

template <ArrayType ARRAY_TYPE, typename T, typename ARRAY_TRAITS, typename OFFSET_SETTER = DummyOffsetSetter>
BitSize initializeOffsets(const ArrayView<T, ARRAY_TRAITS>& array, BitSize bitPosition,
        const OFFSET_SETTER& offsetSetter = OFFSET_SETTER())
{
    using ValueType = typename ArrayView<T, ARRAY_TRAITS>::ValueType;

    BitSize endBitPosition = bitPosition;

    if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
    {
        endBitPosition += bitSizeOf(fromCheckedValue<VarSize>(convertSizeToUInt32(array.size())));
    }

    for (size_t i = 0; i < array.size(); ++i)
    {
        if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            endBitPosition = alignTo(8, endBitPosition);
            offsetSetter.setOffset(i, endBitPosition / 8);
        }

        using AtResult = decltype(std::declval<const ArrayView<T, ARRAY_TRAITS>&>().at(std::declval<size_t>()));
        if constexpr (std::is_same_v<View<ValueType>, AtResult>)
        {
            endBitPosition += initializeOffsets(array[i], endBitPosition);
        }
        else
        {
            endBitPosition += bitSizeOf(array[i], endBitPosition);
        }
    }

    return endBitPosition - bitPosition;
}

template <ArrayType ARRAY_TYPE, typename ARRAY_TRAITS>
size_t readArrayLength(BitStreamReader& reader, size_t arrayLength)
{
    if constexpr (ARRAY_TYPE == ArrayType::NORMAL || ARRAY_TYPE == ArrayType::ALIGNED)
    {
        return arrayLength;
    }
    else if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
    {
        return reader.readVarSize();
    }
    else
    {
        const size_t remainingBits = reader.getBufferBitSize() - reader.getBitPosition();
        return remainingBits / ARRAY_TRAITS::bitSizeOf();
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ALLOC, typename ARRAY_TRAITS = ArrayTraits<T>>
void read(BitStreamReader& reader, Vector<T, ALLOC>& rawArray, detail::array_owner_type_t<ARRAY_TRAITS>& owner,
        size_t arrayLength = 0)
{
    const size_t readLength = readArrayLength<ARRAY_TYPE, ARRAY_TRAITS>(reader, arrayLength);
    rawArray.clear();
    rawArray.reserve(readLength);
    for (size_t i = 0; i < readLength; ++i)
    {
        if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            reader.alignTo(8);
        }
        rawArray.emplace_back();
        ARRAY_TRAITS::read(reader, owner, rawArray.back(), i);
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ALLOC,
        std::enable_if_t<is_dummy_array_owner_v<detail::array_owner_type_t<ArrayTraits<T>>>, int> = 0>
void read(BitStreamReader& reader, Vector<T, ALLOC>& rawArray, size_t arrayLength = 0)
{
    DummyArrayOwner owner;
    read<ARRAY_TYPE, T, ALLOC>(reader, rawArray, owner, arrayLength);
}

template <ArrayType ARRAY_TYPE, typename ARRAY_TRAITS, typename T, typename ALLOC>
void readWithTraits(BitStreamReader& reader, Vector<T, ALLOC>& rawArray,
        detail::array_owner_type_t<ARRAY_TRAITS>& owner, size_t arrayLength = 0)
{
    read<ARRAY_TYPE, T, ALLOC, ARRAY_TRAITS>(reader, rawArray, owner, arrayLength);
}

template <ArrayType ARRAY_TYPE, typename ARRAY_TRAITS, typename T, typename ALLOC,
        std::enable_if_t<is_dummy_array_owner_v<detail::array_owner_type_t<ARRAY_TRAITS>>, int> = 0>
void readWithTraits(BitStreamReader& reader, Vector<T, ALLOC>& rawArray, size_t arrayLength = 0)
{
    DummyArrayOwner owner;
    readWithTraits<ARRAY_TYPE, ARRAY_TRAITS, T, ALLOC>(reader, rawArray, owner, arrayLength);
}

template <ArrayType ARRAY_TYPE, typename T, typename ARRAY_TRAITS>
void write(BitStreamWriter& writer, const ArrayView<T, ARRAY_TRAITS>& array)
{
    if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
    {
        write(writer, fromCheckedValue<VarSize>(convertSizeToUInt32(array.size())));
    }

    for (size_t i = 0; i < array.size(); ++i)
    {
        if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            writer.alignTo(8);
        }

        write(writer, array[i]);
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ARRAY_TRAITS>
BitSize bitSizeOfPacked(const ArrayView<T, ARRAY_TRAITS>& array, BitSize bitPosition = 0)
{
    if constexpr (is_packable_v<T>)
    {
        using ValueType = typename ArrayView<T, ARRAY_TRAITS>::ValueType;

        static_assert(ARRAY_TYPE != ArrayType::IMPLICIT, "Implicit array cannot be packed!");

        BitSize endBitPosition = bitPosition;

        const size_t arrayLength = array.size();
        if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            endBitPosition += bitSizeOf(fromCheckedValue<VarSize>(convertSizeToUInt32(arrayLength)));
        }

        if (arrayLength > 0)
        {
            detail::packing_context_type_t<ValueType> context;

            for (size_t i = 0; i < arrayLength; ++i)
            {
                initContext(context, array[i]);
            }

            for (size_t i = 0; i < arrayLength; ++i)
            {
                if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
                {
                    endBitPosition = alignTo(8, endBitPosition);
                }

                endBitPosition += bitSizeOf(context, array[i], endBitPosition);
            }
        }

        return endBitPosition - bitPosition;
    }
    else
    {
        return bitSizeOf<ARRAY_TYPE>(array, bitPosition);
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ARRAY_TRAITS, typename OFFSET_SETTER = DummyOffsetSetter>
BitSize initializeOffsetsPacked(const ArrayView<T, ARRAY_TRAITS>& array, BitSize bitPosition,
        const OFFSET_SETTER& offsetSetter = OFFSET_SETTER())
{
    if constexpr (is_packable_v<T>)
    {
        using ValueType = typename ArrayView<T, ARRAY_TRAITS>::ValueType;

        static_assert(ARRAY_TYPE != ArrayType::IMPLICIT, "Implicit array cannot be packed!");

        BitSize endBitPosition = bitPosition;

        const size_t arrayLength = array.size();
        if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            endBitPosition += bitSizeOf(fromCheckedValue<VarSize>(convertSizeToUInt32(arrayLength)));
        }

        if (arrayLength > 0)
        {
            detail::packing_context_type_t<ValueType> context;

            for (size_t i = 0; i < arrayLength; ++i)
            {
                initContext(context, array[i]);
            }

            for (size_t i = 0; i < arrayLength; ++i)
            {
                if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
                {
                    endBitPosition = alignTo(8, endBitPosition);
                    offsetSetter.setOffset(i, endBitPosition / 8);
                }

                using AtResult =
                        decltype(std::declval<const ArrayView<T, ARRAY_TRAITS>&>().at(std::declval<size_t>()));
                if constexpr (std::is_same_v<View<ValueType>, AtResult>)
                {
                    endBitPosition += initializeOffsets(context, array[i], endBitPosition);
                }
                else
                {
                    endBitPosition += bitSizeOf(context, array[i], endBitPosition);
                }
            }
        }

        return endBitPosition - bitPosition;
    }
    else
    {
        return initializeOffsets<ARRAY_TYPE>(array, bitPosition, offsetSetter);
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ARRAY_TRAITS>
void writePacked(BitStreamWriter& writer, const ArrayView<T, ARRAY_TRAITS>& array)
{
    if constexpr (is_packable_v<T>)
    {
        using ValueType = typename ArrayView<T, ARRAY_TRAITS>::ValueType;

        static_assert(ARRAY_TYPE != ArrayType::IMPLICIT, "Implicit array cannot be packed!");

        const size_t arrayLength = array.size();
        if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            write(writer, fromCheckedValue<VarSize>(convertSizeToUInt32(array.size())));
        }

        if (arrayLength > 0)
        {
            detail::packing_context_type_t<ValueType> context;

            for (size_t i = 0; i < arrayLength; ++i)
            {
                initContext(context, array[i]);
            }

            for (size_t i = 0; i < arrayLength; ++i)
            {
                if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
                {
                    writer.alignTo(8);
                }

                write(context, writer, array[i]);
            }
        }
    }
    else
    {
        write<ARRAY_TYPE>(writer, array);
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ALLOC, typename ARRAY_TRAITS = ArrayTraits<T>>
void readPacked(BitStreamReader& reader, Vector<T, ALLOC>& rawArray,
        detail::array_owner_type_t<ARRAY_TRAITS>& owner, size_t arrayLength = 0)
{
    if constexpr (is_packable_v<T>)
    {
        using ValueType = T;

        const size_t readLength = readArrayLength<ARRAY_TYPE, ARRAY_TRAITS>(reader, arrayLength);
        rawArray.clear();

        if (readLength > 0)
        {
            rawArray.reserve(readLength);

            detail::packing_context_type_t<ValueType> context;

            for (size_t i = 0; i < readLength; ++i)
            {
                if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
                {
                    reader.alignTo(8);
                }
                rawArray.emplace_back();
                ARRAY_TRAITS::read(context, reader, owner, rawArray.back(), i);
            }
        }
    }
    else
    {
        read<ARRAY_TYPE, T, ALLOC, ARRAY_TRAITS>(reader, rawArray, owner, arrayLength);
    }
}

template <ArrayType ARRAY_TYPE, typename T, typename ALLOC,
        typename ARRAY_TRAITS = ArrayTraits<std::remove_cv_t<T>>,
        std::enable_if_t<is_dummy_array_owner_v<detail::array_owner_type_t<ARRAY_TRAITS>>, int> = 0>
void readPacked(BitStreamReader& reader, Vector<T, ALLOC>& rawArray, size_t arrayLength = 0)
{
    DummyArrayOwner owner;
    readPacked<ARRAY_TYPE, T, ALLOC, ARRAY_TRAITS>(reader, rawArray, owner, arrayLength);
}

template <ArrayType ARRAY_TYPE, typename ARRAY_TRAITS, typename T, typename ALLOC>
void readPackedWithTraits(BitStreamReader& reader, Vector<T, ALLOC>& rawArray,
        detail::array_owner_type_t<ARRAY_TRAITS>& owner, size_t arrayLength = 0)
{
    readPacked<ARRAY_TYPE, T, ALLOC, ARRAY_TRAITS>(reader, rawArray, owner, arrayLength);
}

template <ArrayType ARRAY_TYPE, typename ARRAY_TRAITS, typename T, typename ALLOC,
        std::enable_if_t<is_dummy_array_owner_v<detail::array_owner_type_t<ARRAY_TRAITS>>, int> = 0>
void readPackedWithTraits(BitStreamReader& reader, Vector<T, ALLOC>& rawArray, size_t arrayLength = 0)
{
    DummyArrayOwner owner;
    readPackedWithTraits<ARRAY_TYPE, ARRAY_TRAITS, T, ALLOC>(reader, rawArray, owner, arrayLength);
}

} // namespace detail

template <typename T, typename ARRAY_TRAITS>
uint32_t calcHashCode(uint32_t seedValue, const ArrayView<T, ARRAY_TRAITS>& array)
{
    uint32_t result = seedValue;
    for (size_t i = 0; i < array.size(); ++i)
    {
        result = calcHashCode(result, array[i]);
    }

    return result;
}

} // namespace zserio

#endif // ZSERIO_ARRAY_H_INC
